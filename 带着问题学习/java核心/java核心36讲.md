1. ##### java平台的理解？

    `java`生态趋于完善，最为显著的特性是其一次编写，到处运行，即跨平台性；以及`JVM`提供的内存自动管理，即垃圾收集。

   `JRE`: `java`核心类库、`JVM`虚拟机、以及一些模块

   `JDK`:包含JRE的基础上，还额外添加了一些工具，如编译器（`javac`）和各种诊断工具等

   关于`java`的"一次编写，到处运行"的理解；`java`通过编译器将源代码编译成为字节码；在运行时通过`JVM`内嵌的解释器将字节码解释成为机器码执行；但是常见的`JVM`，都有`JIT`（即时编译器），它会将执行时的热点代码直接编译成字节码，以优化程序的执行速度。所以`java`跨平台的特性重点是在其`JVM`，`JVM`值负责解析符合规范的字节码文件，所以理论上任何语言只要能生成对应的字节码文件，都可以在`JVM`上执行。

------

2. ##### 请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？

![image-20200313102349453](E:\study_doc\syudy_doc\带着问题学习\java核心\exception.png)

> ​	派生于`ERROR `和` RuntimeException`的异常统称为非检查（`unchecked`）异常
>
> ​	其他所有的称为检查型（`checked`）异常，即需要自行捕获或抛出

------

3. ##### final, finally, finalize 有什么不同？

   **final**：可以用来修饰类、方法、变量，分别有不同的意义，`final` 修饰的 `class` 代表不可以继承扩展，`final` 的变量是不可以修改的，而 final 的方法也是不可以重写的（`override`）。

   **finally**：是` Java `保证重点代码一定要被执行的一种机制。我们可以使用 `try-finally` 或者` try-catch-finally` 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。finally总是被执行，除非程序或线程被中断。

   **finalize**：基础类 `java.lang.Object` 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。但不能完全依靠finalize来进行资源的回收，`finalize`只能作为最后的防护网，即当资源未回收时，`finalize`可能会`GC`前进行回收，但是并不能保证它什么时候执行，执行结果是否符合预期。且实现非空的`finalize`方法时，会拖慢垃圾收集，导致大量对象堆积，严重时会导致`OOM`。

   *`String`为什么是`final`的？*

   - 为了实现字符串常量池

   - 为了线程安全

   - 为了实现`HashCode`的不可变性

   - `Java`语言并不是操作系统本地语言，必须借助操作系统本地的`API`即`本地方法调用`来实现很多底层的功能，所以为了安全起见，string被设计为不可变的，以避免无意或恶意的对操作系统带来损害。

     ------

4. ##### 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？

   在java语言中，除基本数据类型外，其他所有都是指向各类对象的对象引用；根据其生命周期的长短，可分为4类：

   - **强引用：**通过`new`创建的对象所关联的引用就是强引用的。当`JVM`内存空间不足时，宁愿抛出`OOM`也不会随意回收具有强引用的存活对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 `null`，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。
   - **软引用：**通过`SoftReference`类实现。只有当`JVM`内存空间不足时，才会试图去回收软引用所指向的对象，`JVM`会确保在`OOM`前清理软引用指向的对象。多用于内存敏感的缓存，只有当内存空间不足时才会清理掉，这样既保证了使用缓存的同时也不会耗尽内存。
   - **弱引用：**通过`WeakReference`类实现。当垃圾回收线程扫描到具有弱引用的的对象时，便会对其进行回收。
   - **虚引用：**虚引用也叫幻象引用，通过`PhantomReference`类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 `finalize` 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。

   ------

5. 理解 Java 的字符串，`String`、`StringBuffer`、`StringBuilder` 有什么区别？

   **String：**由于`String`在Java世界中使用过于频繁，`Java`为了避免在一个系统中产生大量的`String`对象，引入了字符串常量池。其运行机制是：创建一个字符串时，首先检查池中是否有值相同的字符串对象，如果有则不需要创建直接从池中刚查找到的对象引用；如果没有则新建字符串对象，返回对象引用，并且将新创建的对象放入池中。但是，通过new方法创建的`String`对象是不检查字符串池的，而是直接在堆区或栈区创建一个新的对象，也不会把对象放入池中。可以通过`intern()`方法将`new`的对象添加到字符串常量池。

   > `String str1 = "123";` //通过直接量赋值方式，放入字符串常量池
   > `String str2 = new String(“123”);`//通过new方式赋值方式，不放入字符串常量池

   **StringBuffer、StringBuilder：**都实现了`AbstractStringBuilder`抽象类，拥有几乎一致对外提供的调用接口；其底层在内存中的存储方式与`String`相同，都是以一个有序的字符序列（`char`类型的数组）进行存储，不同点是`StringBuffer/StringBuilder`对象的值是可以改变的，并且值改变以后，对象引用不会发生改变;两者对象在构造过程中，首先按照默认大小申请一个字符数组，由于会不断加入新数据，当超过默认大小后，会创建一个更大的数组，并将原先的数组内容复制过来，再丢弃旧的数组。因此，对于较大对象的扩容会涉及大量的内存复制操作，如果能够预先评估大小，可提升性能。两者区别在于`StringBuffer`的方法在声名时都添加了`synchronize`关键字，以保证其多线程下的安全性。
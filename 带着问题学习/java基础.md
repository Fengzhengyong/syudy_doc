##### 1. Java面向对象的特征？

面向对象的三个基本特征是：封装、继承、多态。

###### a).封装

封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

封装的优点

将变化隔离
便于使用
提高重用性
提高安全性
封装的缺点：

将变量等使用private修饰，或者封装进方法内，使其不能直接被访问，增加了访问步骤与难度！

封装的实现形式

A、使用访问权限修饰符private 在定义JavaBean时对于成员变量使用private进行修饰，同时对外提供set、get方法 使用了private修饰的成员在其他类中不能直接访问，此时需要使用set、get方法进行。
B、定义一个Java类与Java的方法就是最简单最常见的面向对象的封装操作，这些操作符合隐藏实现细节，提供访问方式的思路。

###### b).继承

面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。

通过继承创建的新类称为“子类”或“派生类”。

被继承的类称为“基类”、“父类”或“超类”。

继承的过程，就是从一般到特殊的过程。

要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。

在Java语言中，一个类只能单继承，可以实现多个接口。继承就是子类继承父类的特征和行为，使得子类对象具有父类的非private属性和方法。

类的继承格式:

通过extends关键字申明一个类继承另一个类，如

class父类{}

class子类extends父类{}

为什么需要继承？

减少代码重复、臃肿，提高代码可维护性。
继承的特性：

子类拥有父类非private的属性和方法；
子类可以拥有完全属于自己的属性和方法（对父类扩展）；
Java是单继承(每个子类只能继承一个父类)；但是Java可以是多重继承（如A继承B，B继承C）。
Super和this关键字：

Super关键字：我们可以通过super关键字来实现子类对父类成员的访问，引用当前实例对象的父类。

This关键字：指向实例对象自己的引用。

###### c).多态

多态就是同一个接口，使用不同的实现，而执行不同的操作。

多态的三个必要条件：

继承（extends）
重写（子类重写父类的同名方法）
父类引用指向子类的对象，如：
子类继承父类，重写父类的方法，当子类对象调用重写的方法时，调用的是子类的方法，而不是父类的方法，当想要调用父类中被重写的方法时，则需使用关键字super。

------



##### 2. “面向对象六大原则”？

单一职责原则(Single-Resposibility Principle)
开放封闭原则(Open-Closed principle)
Liskov替换原则(Liskov-Substituion Principle)
依赖倒置原则(Dependecy-Inversion Principle)
接口隔离原则(Interface-Segregation Principle)
良性依赖原则

------



##### 3. 谈谈final、finally、finalize的区别?

###### a).final

根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。
	final类不能被继承，没有子类，final类中的方法默认是final的。
	final方法不能被子类的方法覆盖，但可以被继承。
	final成员变量表示常量，只能被赋值一次，赋值后值不再改变。
	final不能用于修饰构造方法。
	

###### b).finally

finally是关键字，在异常处理中，try子句中执行需要运行的内容，catch子句用于捕获异常，finally子句表示不管是否发生异常，都会执行。finally可有可无。但是try...catch必须成对出现。

###### c).finalize()

finalize() 方法名，Object类的方法，Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象进行调用。
finalize()方法是在垃圾收集器删除对象之前对这个对象调用的子类覆盖 finalize() 方法以整理系统资源或者执行其他清理操作。但是finalize并不是可靠的，不能完全依赖finalize来对相关资源做释放和清理，但是
finalize是可以作为最差情况下的清理方式的，毕竟finalize只是不知道什么时候会进行清理，而不是不清理。

------



##### 4. Java 中的 ==, equals 与 hashCode 的区别与联系？

== ： 该操作符生成的是一个boolean结果，它计算的是操作数的值之间的关系

equals ： Object 的 实例方法，比较两个对象的content是否相同
	Object中的equals():
		public boolean equals(Object obj){
	    	return (this == obj);
		}
	其实跟 == 是相同的，但是通常情况下，java中的常用的一些类型如String等，都会进行hashcode和equals方法的重写，所以才说equals方法比较的是两个对象的content


hashCode ： Object 的 native方法 , 获取对象的哈希值，用于确定该对象在哈希表中的索引位置，它实际上是一个int型整数。

hashCode和equlas的关系

1、如果两个对象相同（即用equals比较返回true），那么它们的hashCode值一定要相同；
2、如果两个对象的hashCode相同，它们并不一定相同(即用equals比较返回false)
原因：从散列的角度考虑，不同的对象计算哈希码的时候，可能引起冲突。

------



##### 5. 反射？

可以在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。
动态代理：a.JDK[接口实现] b.CGLIB[通过继承]

------



##### 6. StringBuilder 为什么线程不安全？

StringBuilder的append()方法调用的父类AbstractStringBuilder的append()方法，而其中的成员变量不是线程安全的，所以在多线程情况下，成员变量的变化会跟预期的不一样，例如count += len时，当两个线程都执行完毕时，可能
count的值还是等于count+len，而不是count+len(1)+len(2),这种情况下就会出现实际char[]的数量与预期不一致，且由于StringBuilder在添加元素时会检查当前char[]能否容纳数据，如果不能容纳时会进行扩容。扩容的逻辑就是new一个
新的char数组，新的char数组的容量是原来char数组的两倍再加2，再通过System.arryCopy()函数将原数组的内容复制到新数组，最后将指针指向新的char数组。所以可能会出现线程一添加第n个元素时，count=n，而线程二已经完成了添加，
则count=n+1,此时出现扩容，则线程一将会用下标n+1去取char[]中的元素，则会出现ArrayIndexOutOfBoundsException异常。
StringBuffer的append()方法如下：
public synchronized StringBuffer append(String str) {
     toStringCache = null;
     super.append(str);
     return this;
 }
StringBuffer在对AbstractStringBuilder.append()进行了重写，添加了synchronized 锁，使用方法是线程安全的

------



##### 7. 反射的作用与原理 ?

Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法； 
在运行时调用任意一个对象的方法；生成动态代理。

------



##### 8. java对象

对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充

实例数据：存放类的属性数据信息，包括父类的属性信息；
对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐；
对象头：Java对象头一般占有2个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit，在64位虚拟机中，1个机器码是8个字节，也就是64bit），但是 如果对象是数组类型，则需要3个机器码，
	因为JVM虚拟机可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确认数组的大小，所以用一块来记录数组长度。

------



##### 9. java的线程模型 

###### 9.1 线程类型：

- ​	内核线程（KLT）： 直接由操作系统内核支持的线程 

- ​	轻量级进程（KWP）： 系统提供给用户的操作内核线程的接口的实现 

- ​	用户线程（UT）： 建立在用户空间的线程库上，系统内核不能感知线程存在的实现 

###### 9.2 线程模型

- ​	一对一

![](E:\study_doc\syudy_doc\pic\线程模型\1_to_1.jpg)

```
一对一模型即轻量级进程的实现模式。一个LWP对应一个KLT。

 优点：每个LWP都是独立的调度单元，一个线程阻塞不影响其他线程。
 缺点：因为与KLT一对一。而KLT创建，调度需要一定内核资源，因此创建数量有限
```



- 一对多

  ![](E:\study_doc\syudy_doc\pic\线程模型\1_to_n.jpg)

```
一对多模型及用户线程实现方式。一个进程对应多个UT。

优点：线程的管理在用户空间进行，比较高效。

缺点：需要用户自己考虑线程的调度相关问题，因为系统对UT无感知，所以一个线程阻塞会导致进程阻塞。
```

- 多对多

![](E:\study_doc\syudy_doc\pic\线程模型\n_to_n.jpg)

```
在一对多的基础上引入KLT。即一个进程管理多个KLT，KLT对应多个UT。
将 n 个UT映射到m个KLT上，要求 m <= n。

优点： 集合了前两种模型的优点，去掉了他们的缺点。
缺点：全是优点。
```

###### 9.3 java线程模型

	java中默认使用了一对一模型。不过其可进行控制，相关参数：-XX:+UseLWPSynchronization（默认值）;
	-XX:+UseBoundThreads。
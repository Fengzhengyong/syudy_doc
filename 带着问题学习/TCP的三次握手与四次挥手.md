## 								TCP的三次握手与四次挥手

突然又看到TCP的三次握手与四次挥手，然后想了想怎么感觉自己凌乱了，整理一下留着以后看^_^

1. ##### TCP报文格式

   ![TCP报文](F:\文档\pic\TCP报文.png)

   （1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
   （2）确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。
   （3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
                   （A）URG：紧急指针（urgent pointer）有效。
                   （B）ACK：确认序号有效。
                   （C）PSH：接收方应该尽快将这个报文交给应用层。
                   （D）RST：重置连接。
                   （E）SYN：发起一个新连接。
                   （F）FIN：释放一个连接。

           需要注意的是：
                   （A）不要将确认序号Ack与标志位中的ACK搞混了。
                   （B）确认方Ack=发起方Req+1，两端配对。

2. ------

   ##### 三次握手与四次挥手

![TCP的三次握手与四次挥手流程图](F:\文档\pic\TCP的三次握手与四次挥手流程图.png)

​	注： MSL(最大报文段生存时间) 

​	*具体的就不多写了，看图理解就行，或者直接拿wiresharkh抓包看一下*

------



3. ##### 了解项

   当TCP使用短连接时，数据交互完毕则关闭连接。

   当使用长连接时，数据交互完毕并不会直接关闭连接，如果在连接持续时间内，连接出现异常，但服务端依旧会维持这些连接，那么长久以往则会有很多打开的半连接，消耗服务器资源，及数据传送失败等。所以服务器需要快速感知到连接失效，减少无效连接，所以有了TCP的保活探测(keepalive)机制【默认不开启】。

   ```
   (1) TCP参数（针对所有TCP连接）
   
   	tcp_keepalive_time
   
   	最后一次数据交换到TCP发送第一个保活探测报文的时间，即允许连接空闲的时间，默认为7200s。
   
   	tcp_keepalive_intvl
   
   	保活探测报文的重传时间，默认为75s。
   
   	tcp_keepalive_probes
   
   	保活探测报文的发送次数，默认为9次。
   
   (2) TCP层选项（仅针对一个TCP连接）
   
   	TCP_KEEPIDLE：含义同tcp_keepalive_time。
   
   	TCP_KEEPINTVL：含义同tcp_keepalive_intvl。
   
   	TCP_KEEPCNT：含义同tcp_keepalive_probes。
   ```

   当启用TCP_KEEPALIVE时，若一个连接在tcp_keepalive_time内无任何响应，则服务端会发送一个探测包检测连接是否正常。

   ​	a. 正常,则tcp_keepalive_time后再试。

   ​	b. 客户端崩溃，服务器无法收到确认包。则每隔75s发送一次探测报文，一共发9次。

   ​	c. 客户端崩溃已重启。客户端回复RST，服务器收到后关闭连接。

   ​	d. 客户端正常，服务器不可达。服务器无法区分是客户端异常还是中间链路异常，默认为b。

   ###### 也可以使用TCP_USER_TIMEOUT，显式的指定当发送数据多久后还没有得到响应，就判定连接超时 ，而TCP_USER_TIMEOUT也会影响到以下两种定时器：

   （1）超时重传定时器

   ​	判断连接是否超时，分3种情况：

   1. SYN包：当SYN包的重传次数达到上限时，判定连接超时。(默认允许重传5次，初始超时时间为1s，总共历时31s)
   2. 非SYN包，用户使用TCP_USER_TIMEOUT：当数据包发出去后的等待时间超过用户设置的时间时，判定连接超时。
   3. 非SYN包，用户没有使用TCP_USER_TIMEOUT：当数据包发出去后的等待时间超过以TCP_RTO_MIN为初始超时时间，重传boundary次所花费的时间后，判定连接超时。(boundary的最大值为tcp_retries2，默认值为15)

   （2） 保活定时器

   ​	判断连接是否异常，分2种情况：

   1. 用户使用了TCP_USER_TIMEOUT选项。当连接的空闲时间超过了用户设置的时间，且有发送过探测报文。

   2. 用户没有使用TCP_USER_TIMEOUT选项。当发送保活探测包的次数达到了保活探测的最大次数时。

   ------

   

4. ##### 思考

   （1） 四次挥手的意义？

   ​	等待服务器发送剩余的数据包，并保证双全工通道的正常关闭。

   （2） 三次握手的意义？

   ​	a.  三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步		骤，如果是两次握手则只能保证client端的起始序号被确认，无法保证服务端的起始序号被接收并确认。

   ​	b.  为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误 。

   （3） Client为什么不直接Close,而是TIME_WAIT?

   1. 等待确认消息回传给server端，如果ACK消息出现丢失server端会重发FIN消息。
   2. 保证本次传输中的报文段都已死亡，以避免干扰下一次的连接。

   ```
   注：每个报文段的最大生产存时间为MSL。当server端收不到client端的确认消息时，会进行重发FIN消息，则丢失消息+重传的消息最大生存时间为2MSL。
   ```

   

​	